
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://wgnvrxubwifcscrbkimm.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndnbnZyeHVid2lmY3NjcmJraW1tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg1MjYxNzAsImV4cCI6MjA1NDEwMjE3MH0.AwaBd1VRrzz_DvvDjJ3Ke7CJFoxl5XUB2chymhueybg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper function to check if user has an active subscription
export const checkUserSubscription = async (userId: string) => {
  if (!userId) return false;
  
  try {
    const { data, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("user_id", userId)
      .eq("status", "active")
      .maybeSingle();
    
    if (error) {
      console.error("Error checking subscription:", error);
      return false;
    }
    
    return !!data;
  } catch (error) {
    console.error("Error in subscription check:", error);
    return false;
  }
};

// Helper to update user profile with CPF
export const updateUserProfile = async (userId: string, cpf: string) => {
  try {
    // Use the from() method and cast to any to bypass TypeScript checking
    // This is a temporary workaround until the types are updated
    const { error } = await supabase
      .from("profiles")
      .update({ 
        cpf 
      } as any)
      .eq("id", userId);
    
    if (error) {
      console.error("Error updating profile with CPF:", error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in profile update:", error);
    return false;
  }
};

// Helper to remove duplicate transactions
export const removeDuplicateTransactions = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      console.error("No user found");
      return { removed: 0 };
    }
    
    // First get all transactions
    const { data: allTransactions, error } = await supabase
      .from("transactions")
      .select("*")
      .eq("user_id", user.id)
      .order("date", { ascending: false });
      
    if (error) {
      console.error("Error fetching transactions:", error);
      return { removed: 0 };
    }
    
    if (!allTransactions || allTransactions.length === 0) {
      console.info("No transactions found");
      return { removed: 0 };
    }
    
    // Find duplicates by creating a signature for each transaction
    const seen = new Map();
    const duplicates = [];
    
    for (const transaction of allTransactions) {
      // Create a unique signature for the transaction based on key properties
      const signature = `${transaction.date}|${transaction.description}|${transaction.received_from}|${transaction.payment_type}|${transaction.amount}`;
      
      if (seen.has(signature)) {
        // This is a duplicate, keep the one we've already seen and mark this for deletion
        duplicates.push(transaction.id);
      } else {
        seen.set(signature, transaction.id);
      }
    }
    
    console.info(`Found ${duplicates.length} duplicate transactions`);
    
    // Delete duplicates if any were found
    if (duplicates.length > 0) {
      const { error: deleteError } = await supabase
        .from("transactions")
        .delete()
        .in("id", duplicates);
        
      if (deleteError) {
        console.error("Error deleting duplicates:", deleteError);
        return { removed: 0 };
      }
    }
    
    console.info(`Removed ${duplicates.length} duplicate transactions`);
    return { removed: duplicates.length };
  } catch (error) {
    console.error("Error in removeDuplicateTransactions:", error);
    return { removed: 0 };
  }
};

// Create a Stripe checkout session
export const createStripeCheckout = async (priceId: string) => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      throw new Error("No session found. User must be logged in.");
    }
    
    const { data, error } = await supabase.functions.invoke("create-checkout", {
      body: {
        priceId,
        successUrl: `${window.location.origin}/dashboard?payment=success`,
        cancelUrl: `${window.location.origin}/subscription?payment=canceled`,
      },
    });
    
    if (error) {
      console.error("Error creating checkout session:", error);
      throw new Error(error.message);
    }
    
    return data;
  } catch (error) {
    console.error("Error in createStripeCheckout:", error);
    throw error;
  }
};

// Get user subscription data
export const getUserSubscription = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return null;
    }
    
    const { data, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("user_id", user.id)
      .maybeSingle();
      
    if (error) {
      console.error("Error fetching subscription:", error);
      return null;
    }
    
    return data;
  } catch (error) {
    console.error("Error in getUserSubscription:", error);
    return null;
  }
};
