// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://wgnvrxubwifcscrbkimm.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndnbnZyeHVid2lmY3NjcmJraW1tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg1MjYxNzAsImV4cCI6MjA1NDEwMjE3MH0.AwaBd1VRrzz_DvvDjJ3Ke7CJFoxl5XUB2chymhueybg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper function to check if user has an active subscription
export const checkUserSubscription = async (userId: string) => {
  if (!userId) return false;
  
  try {
    const { data, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("user_id", userId)
      .eq("status", "active")
      .maybeSingle();
    
    if (error) {
      console.error("Error checking subscription:", error);
      return false;
    }
    
    return !!data;
  } catch (error) {
    console.error("Error in subscription check:", error);
    return false;
  }
};

// Helper to update user profile with CPF
export const updateUserProfile = async (userId: string, cpf: string) => {
  try {
    const { error } = await supabase
      .from("profiles")
      .update({ 
        cpf 
      } as any)
      .eq("id", userId);
    
    if (error) {
      console.error("Error updating profile with CPF:", error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in profile update:", error);
    return false;
  }
};

// Helper to remove duplicate transactions
export const removeDuplicateTransactions = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      console.error("No user found");
      return { removed: 0 };
    }
    
    const { data: allTransactions, error } = await supabase
      .from("transactions")
      .select("*")
      .eq("user_id", user.id)
      .order("date", { ascending: false });
      
    if (error) {
      console.error("Error fetching transactions:", error);
      return { removed: 0 };
    }
    
    if (!allTransactions || allTransactions.length === 0) {
      console.info("No transactions found");
      return { removed: 0 };
    }
    
    const seen = new Map();
    const duplicates = [];
    
    for (const transaction of allTransactions) {
      const signature = `${transaction.date}|${transaction.description}|${transaction.received_from}|${transaction.payment_type}|${transaction.amount}`;
      
      if (seen.has(signature)) {
        duplicates.push(transaction.id);
      } else {
        seen.set(signature, transaction.id);
      }
    }
    
    console.info(`Found ${duplicates.length} duplicate transactions`);
    
    if (duplicates.length > 0) {
      const { error: deleteError } = await supabase
        .from("transactions")
        .delete()
        .in("id", duplicates);
        
      if (deleteError) {
        console.error("Error deleting duplicates:", deleteError);
        return { removed: 0 };
      }
    }
    
    console.info(`Removed ${duplicates.length} duplicate transactions`);
    return { removed: duplicates.length };
  } catch (error) {
    console.error("Error in removeDuplicateTransactions:", error);
    return { removed: 0 };
  }
};

// Create a Stripe checkout session
export const createStripeCheckout = async (priceId: string) => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      throw new Error("No session found. User must be logged in.");
    }
    
    const { data, error } = await supabase.functions.invoke("create-checkout", {
      body: {
        priceId,
        successUrl: `${window.location.origin}/payment/success`,
        cancelUrl: `${window.location.origin}/payment/canceled`,
      },
    });
    
    if (error) {
      console.error("Error creating checkout session:", error);
      throw new Error(error.message);
    }
    
    return data;
  } catch (error) {
    console.error("Error in createStripeCheckout:", error);
    throw error;
  }
};

// Get user subscription data
export const getUserSubscription = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return null;
    }
    
    const { data, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("user_id", user.id)
      .maybeSingle();
      
    if (error) {
      console.error("Error fetching subscription:", error);
      return null;
    }
    
    return data;
  } catch (error) {
    console.error("Error in getUserSubscription:", error);
    return null;
  }
};

// Helper function to delete a journal entry
export const deleteJournalEntry = async (entryId: string) => {
  try {
    console.log('Deleting journal entry with ID:', entryId);
    
    if (!entryId) {
      throw new Error("Invalid entry ID");
    }
    
    // Perform the deletion
    const { error, count } = await supabase
      .from("journal_entries")
      .delete({ count: 'exact' })
      .eq('id', entryId);
      
    if (error) {
      console.error('Error deleting journal entry:', error);
      throw error;
    }
    
    console.log(`Deleted ${count} entries with ID ${entryId}`);
    return { success: true, count };
  } catch (error) {
    console.error('Error in deleteJournalEntry:', error);
    throw error;
  }
};

// Helper function to fetch journal entries
export const fetchJournalEntries = async () => {
  try {
    const { data, error } = await supabase
      .from('journal_entries')
      .select('*')
      .order('created_at', { ascending: false });
      
    if (error) {
      console.error('Error fetching journal entries:', error);
      throw error;
    }
    
    console.log(`Fetched ${data?.length || 0} journal entries`);
    return data || [];
  } catch (error) {
    console.error('Error in fetchJournalEntries:', error);
    throw error;
  }
};
