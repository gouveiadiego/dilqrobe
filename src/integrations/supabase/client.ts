// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://wgnvrxubwifcscrbkimm.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndnbnZyeHVid2lmY3NjcmJraW1tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzg1MjYxNzAsImV4cCI6MjA1NDEwMjE3MH0.AwaBd1VRrzz_DvvDjJ3Ke7CJFoxl5XUB2chymhueybg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper function to check if user has an active subscription
export const checkUserSubscription = async (userId: string) => {
  if (!userId) return false;
  
  try {
    const { data, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("user_id", userId)
      .eq("status", "active")
      .maybeSingle();
    
    if (error) {
      console.error("Error checking subscription:", error);
      return false;
    }
    
    return !!data;
  } catch (error) {
    console.error("Error in subscription check:", error);
    return false;
  }
};

// Helper to update user profile with CPF
export const updateUserProfile = async (userId: string, cpf: string) => {
  try {
    const { error } = await supabase
      .from("profiles")
      .update({ 
        cpf 
      } as any)
      .eq("id", userId);
    
    if (error) {
      console.error("Error updating profile with CPF:", error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in profile update:", error);
    return false;
  }
};

// Helper to remove duplicate transactions
export const removeDuplicateTransactions = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      console.error("No user found");
      return { removed: 0 };
    }
    
    const { data: allTransactions, error } = await supabase
      .from("transactions")
      .select("*")
      .eq("user_id", user.id)
      .order("date", { ascending: false });
      
    if (error) {
      console.error("Error fetching transactions:", error);
      return { removed: 0 };
    }
    
    if (!allTransactions || allTransactions.length === 0) {
      console.info("No transactions found");
      return { removed: 0 };
    }
    
    const seen = new Map();
    const duplicates = [];
    
    for (const transaction of allTransactions) {
      const signature = `${transaction.date}|${transaction.description}|${transaction.received_from}|${transaction.payment_type}|${transaction.amount}`;
      
      if (seen.has(signature)) {
        duplicates.push(transaction.id);
      } else {
        seen.set(signature, transaction.id);
      }
    }
    
    console.info(`Found ${duplicates.length} duplicate transactions`);
    
    if (duplicates.length > 0) {
      const { error: deleteError } = await supabase
        .from("transactions")
        .delete()
        .in("id", duplicates);
        
      if (deleteError) {
        console.error("Error deleting duplicates:", deleteError);
        return { removed: 0 };
      }
    }
    
    console.info(`Removed ${duplicates.length} duplicate transactions`);
    return { removed: duplicates.length };
  } catch (error) {
    console.error("Error in removeDuplicateTransactions:", error);
    return { removed: 0 };
  }
};

// Create a Stripe checkout session
export const createStripeCheckout = async (priceId: string) => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      throw new Error("No session found. User must be logged in.");
    }
    
    const { data, error } = await supabase.functions.invoke("create-checkout", {
      body: {
        priceId,
        successUrl: `${window.location.origin}/payment/success`,
        cancelUrl: `${window.location.origin}/payment/canceled`,
      },
    });
    
    if (error) {
      console.error("Error creating checkout session:", error);
      throw new Error(error.message);
    }
    
    return data;
  } catch (error) {
    console.error("Error in createStripeCheckout:", error);
    throw error;
  }
};

// Get user subscription data
export const getUserSubscription = async () => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return null;
    }
    
    const { data, error } = await supabase
      .from("subscriptions")
      .select("*")
      .eq("user_id", user.id)
      .maybeSingle();
      
    if (error) {
      console.error("Error fetching subscription:", error);
      return null;
    }
    
    return data;
  } catch (error) {
    console.error("Error in getUserSubscription:", error);
    return null;
  }
};

// Helper function to delete a journal entry
export const deleteJournalEntry = async (entryId: string) => {
  try {
    console.log('Deleting journal entry with ID:', entryId);
    
    if (!entryId) {
      throw new Error("Invalid entry ID");
    }
    
    // Get current user ID first
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    
    if (userError) {
      console.error('Error getting user:', userError);
      throw userError;
    }
    
    if (!user) {
      console.error('No authenticated user found');
      throw new Error("User not authenticated");
    }
    
    // First verify that the entry belongs to the current user
    const { data: entryData, error: verifyError } = await supabase
      .from('journal_entries')
      .select('id, user_id')
      .eq('id', entryId)
      .eq('user_id', user.id)
      .single();
      
    if (verifyError) {
      console.error('Error verifying journal entry ownership:', verifyError);
      throw new Error('Could not verify entry ownership');
    }
    
    if (!entryData) {
      console.error('Entry not found or does not belong to current user');
      throw new Error('Entry not found or access denied');
    }
    
    // Now perform the deletion
    const { error, count } = await supabase
      .from("journal_entries")
      .delete({ count: 'exact' })
      .eq('id', entryId)
      .eq('user_id', user.id);
      
    if (error) {
      console.error('Error deleting journal entry:', error);
      throw error;
    }
    
    console.log(`Deleted ${count} entries with ID ${entryId} for user ${user.id}`);
    
    if (count === 0) {
      // If count is 0, try to use the new database function as fallback
      console.log('Attempting direct deletion via RPC function as fallback...');
      
      const { data, error: directError } = await supabase.rpc('delete_journal_entry', { 
        entry_id_param: entryId,
        user_id_param: user.id 
      });
      
      if (directError) {
        console.error('Error in direct deletion via RPC:', directError);
        throw directError;
      }
      
      console.log('Direct deletion result:', data);
      return { success: !!data, count: data ? 1 : 0 };
    }
    
    return { success: count > 0, count };
  } catch (error) {
    console.error('Error in deleteJournalEntry:', error);
    throw error;
  }
};

// Helper function to fetch journal entries
export const fetchJournalEntries = async () => {
  try {
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    
    if (userError) {
      console.error('Error getting user:', userError);
      throw userError;
    }
    
    if (!user) {
      console.error('No authenticated user found');
      throw new Error("User not authenticated");
    }
    
    const { data, error } = await supabase
      .from('journal_entries')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });
      
    if (error) {
      console.error('Error fetching journal entries:', error);
      throw error;
    }
    
    console.log(`Fetched ${data?.length || 0} journal entries`);
    return data || [];
  } catch (error) {
    console.error('Error in fetchJournalEntries:', error);
    throw error;
  }
};

// Helper function to update challenge rankings
export const updateChallengeRankings = async (challengeId: string) => {
  try {
    // Get all records for this challenge
    const { data: records, error: recordsError } = await supabase
      .from('running_records')
      .select('*')
      .eq('challenge_id', challengeId);
      
    if (recordsError) {
      console.error('Error fetching records for ranking update:', recordsError);
      throw recordsError;
    }
    
    // Get all participants
    const { data: participants, error: participantsError } = await supabase
      .from('challenge_participants')
      .select('*')
      .eq('challenge_id', challengeId);
      
    if (participantsError) {
      console.error('Error fetching participants for ranking update:', participantsError);
      throw participantsError;
    }
    
    // Calculate total distance for each participant
    const updates = participants.map(participant => {
      const userRecords = records.filter(record => record.user_id === participant.user_id);
      const totalDistance = userRecords.reduce((sum, record) => {
        const distance = typeof record.distance === 'string' ? parseFloat(record.distance) : Number(record.distance);
        return sum + (isNaN(distance) ? 0 : distance);
      }, 0);
      const totalRuns = userRecords.length;
      
      return {
        id: participant.id,
        total_distance: totalDistance,
        total_runs: totalRuns
      };
    });
    
    // Update each participant's stats
    for (const update of updates) {
      const { error } = await supabase
        .from('challenge_participants')
        .update({
          total_distance: update.total_distance,
          total_runs: update.total_runs
        })
        .eq('id', update.id);
        
      if (error) {
        console.error(`Error updating participant ${update.id}:`, error);
      }
    }
    
    // Update rankings based on new totals
    const sortedParticipants = [...updates].sort((a, b) => b.total_distance - a.total_distance);
    
    for (let i = 0; i < sortedParticipants.length; i++) {
      const { error } = await supabase
        .from('challenge_participants')
        .update({ ranking: i + 1 })
        .eq('id', sortedParticipants[i].id);
        
      if (error) {
        console.error(`Error updating ranking for participant ${sortedParticipants[i].id}:`, error);
      }
    }
    
    console.log(`Updated rankings for ${sortedParticipants.length} participants in challenge ${challengeId}`);
    return true;
  } catch (error) {
    console.error('Error in updateChallengeRankings:', error);
    return false;
  }
};
